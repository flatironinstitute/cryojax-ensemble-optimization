"""
This module contains the functions to simulate images from a set of atomic
coordinates.
"""

import jax
import jax.numpy as jnp
from jaxtyping import Array

from .rotation import calc_rot_matrix


@jax.jit
def simulator_(
    coords: Array,
    struct_info: dict,
    grid: Array,
    grid_ctf: Array,
    pose_params: Array,
    ctf_params: Array,
) -> Array:
    """
    Simulate a single image.

    Parameters
    ----------
    coords : Array
        Array of shape (3, n_atoms) with the coordinates of the atoms.
    struct_info : Array
        Structural information of the models.
    grid : Array
        Array of shape (box_size, box_size) with the grid coordinates (generated by ImageStack).
    grid_f : Array
        Array of shape (box_size, box_size) with the Fourier grid coordinates (generated by ImageStack).
    resolution : float
        Resolution of density map where this image comes from.
    pose_params : Array
        Array of shape (11) with the following parameters:
            - euler_angles : Euler angles (0, 1, 2)
            - shifts : 2D shifts (3, 4)
            - ctf_defocus : defocus (5)
            - ctf_amp : amplitude contrast (6)
            - ctf_bfactor : B-factor (7)
            - noise_snr : signal-to-noise ratio (9) <- unused here, see add_noise()
            - noise_variance : noise variance (10) <- unused here, see add_noise()

    Returns
    -------
    image : Array
        Array of shape (box_size, box_size) with the simulated image. Images are normalized so that their noiseless version has an l2-norm of 1.

    Notes
    -----
    For the structural information of the models, the first row should be related to the variance of the Gaussian, e.g., the radius of the aminoacid. The second row should be related to the amplitude of the Gaussian, e.g., the number of electrons in the atom/residue (for coarse grained models)
    """

    gauss_var = struct_info["gauss_var"]
    gauss_amp_inv = 1.0 / struct_info["gauss_amp"]

    # Rotate coordinates
    transf_coords = jnp.matmul(calc_rot_matrix(pose_params[2:]), coords)
    transf_coords = (
        transf_coords - jnp.concatenate([pose_params[0:2], jnp.zeros(1)])[:, None]
    )
    gauss_x = (
        jnp.exp(
            -0.5
            * gauss_amp_inv[None, :, :]
            * ((grid[:, None] - transf_coords[0, :]) ** 2)[:, :, None]
        )
        * gauss_var[None, :, :]
    )
    gauss_y = (
        jnp.exp(
            -0.5
            * gauss_amp_inv[None, :, :]
            * ((grid[:, None] - transf_coords[1, :]) ** 2)[:, :, None]
        )
    )
    gauss_x = jnp.transpose(gauss_x, (2, 1, 0))
    gauss_y = jnp.transpose(gauss_y, (2, 0, 1))

    image = -jnp.sum(jnp.matmul(gauss_y, gauss_x), axis=0)

    # Apply CTF
    x = grid_ctf[:, 0]
    y = grid_ctf[:, 1]

    ang = jnp.arctan2(y, x)
    s2 = x**2 + y**2
    defocus = 0.5 * (
        ctf_params[0]
        + ctf_params[1]
        + (ctf_params[0] - ctf_params[1]) * jnp.cos(2 * (ang - ctf_params[2]))
    )

    gamma = (
        2
        * jnp.pi
        * (
            -0.5 * defocus * ctf_params[8] * s2
            + 0.25 * ctf_params[5] * ctf_params[8] ** 3 * s2**2
        )
        - ctf_params[3]
    )

    ctf = jnp.sqrt(1 - ctf_params[4] ** 2) * jnp.sin(gamma) - ctf_params[4] * jnp.cos(
        gamma
    )
    ctf *= ctf_params[7] * jnp.exp(-ctf_params[6] / 4.0 * s2)
    ctf = ctf.reshape(*image.shape)

    image_ft = jnp.fft.fftshift(jnp.fft.fft2(image))
    image = jnp.fft.ifft2(jnp.fft.ifftshift(image_ft * ctf)).real
    image /= jnp.linalg.norm(image)

    return image


batch_simulator_ = jax.vmap(simulator_, in_axes=(0, None, None, None, 0, 0))
