# =============================================================================
# This module contains the functions to simulate images from a set of atomic
# coordinates.
#
import numpy as np
import jax
import jax.numpy as jnp
from jax.typing import ArrayLike
from functools import partial
from typing import Union

from cryo_md.wpa_simulator.rotation import gen_quat, calc_rot_matrix
from cryo_md.image.image_stack import ImageStack


def generate_params_(n_images, config, dtype=float):
    """
    Generate a set of parameters for each image in the stack.

    Parameters
    ----------
    n_images : int
        Number of images in the stack.
    config : dict
        Dictionary with at least the following keys:
            - ctf_defocus : float or list of [min, max]
            - ctf_amp : float or list of [min, max]
            - ctf_bfactor : float or list of [min, max]
            - noise_snr : float or list of [min, max]
    dtype : type, optional
        Data type of the parameters, by default float

    Returns
    -------
    params: ArrayLike
        Array of shape (n_images, 11) with the following columns:
            - quat : quaternion (0, 1, 2, 3)
            - shifts : 2D shifts (4, 5)
            - ctf_defocus : defocus (6)
            - ctf_amp : amplitude contrast (7)
            - ctf_bfactor : B-factor (8)
            - noise_snr : signal-to-noise ratio (9)
            - noise_variance : noise variance (10) <- this is filled in later

    """
    params = np.zeros((n_images, 11), dtype=dtype)

    params[:, 0:4] = gen_quat(n_images, dtype=dtype)
    # params[:, 4:6] = shifts  # TODO

    for i, key in enumerate(["ctf_defocus", "ctf_amp", "ctf_bfactor", "noise_snr"]):
        if isinstance(config[key], float):
            params[:, i + 6] = np.repeat(config[key], n_images)

        elif isinstance(config[key], list) and len(config[key]) == 2:
            params[:, i + 6] = np.random.uniform(
                low=config[key][0], high=config[key][1], size=n_images
            )

        else:
            raise ValueError(
                f"{key} should be a single float value or a list of [min_{key}, max_{key}]"
            )

    return params


def simulator_(
    coords: ArrayLike,
    struct_info: ArrayLike,
    grid: ArrayLike,
    grid_f: ArrayLike,
    res: float,
    var_imaging_args: ArrayLike,
) -> ArrayLike:
    """
    Simulate a single image.

    Parameters
    ----------
    coords : ArrayLike
        Array of shape (3, n_atoms) with the coordinates of the atoms.
    struct_info : ArrayLike
        Structural information of the models.
    grid : ArrayLike
        Array of shape (box_size, box_size) with the grid coordinates (generated by ImageStack).
    grid_f : ArrayLike
        Array of shape (box_size, box_size) with the Fourier grid coordinates (generated by ImageStack).
    res : float
        Resolution of density map where this image comes from.
    var_imaging_args : ArrayLike
        Array of shape (11) with the following parameters:
            - quat : quaternion (0, 1, 2, 3)
            - shifts : 2D shifts (4, 5)
            - ctf_defocus : defocus (6)
            - ctf_amp : amplitude contrast (7)
            - ctf_bfactor : B-factor (8)
            - noise_snr : signal-to-noise ratio (9) <- unused here, see add_noise()
            - noise_variance : noise variance (10) <- unused here, see add_noise()

    Returns
    -------
    image : ArrayLike
        Array of shape (box_size, box_size) with the simulated image. Images are normalized so that their noiseless version has an l2-norm of 1.

    Notes
    -----
    For the structural information of the models, the first row should be related to the variance of the Gaussian, e.g., the radius of the aminoacid. The second row should be related to the amplitude of the Gaussian, e.g., the number of electrons in the atom/residue (for coarse grained models)
    """

    # assert pixel_size < 2.0 * res, "Pixel size should be smaller than 2.0 * res due to the Nyquist limit."

    gauss_var = struct_info[0, :] * res**2
    gauss_amp = struct_info[1, :] / jnp.sqrt(gauss_var * 2.0 * jnp.pi)

    # Rotate coordinates
    coords = jnp.matmul(calc_rot_matrix(var_imaging_args[0:4]), coords)

    gauss_x = gauss_amp * jnp.exp(
        -0.5 * ((grid[:, None] - coords[0, :]) ** 2 / gauss_var)
    )
    gauss_y = gauss_amp * jnp.exp(
        -0.5 * ((grid[:, None] - coords[1, :]) ** 2 / gauss_var)
    )
    image = jnp.matmul(gauss_x, gauss_y.T)

    # # Apply CTF
    elecwavel = 0.019866
    phase = var_imaging_args[6] * jnp.pi * 2.0 * 10000 * elecwavel

    env = jnp.exp(-var_imaging_args[8] * grid_f * 0.5)
    ctf = (
        (
            var_imaging_args[7] * jnp.cos(phase * grid_f * 0.5)
            - jnp.sqrt(1 - var_imaging_args[7] ** 2) * jnp.sin(phase * grid_f * 0.5)
            + 0.0j
        )
        * env
        / var_imaging_args[7]
    )

    # Normalize image
    image = jnp.fft.ifft2(jnp.fft.fft2(image) * ctf).real
    image /= jnp.linalg.norm(image)

    return image


def add_noise_(image, noise_grid, noise_radius_mask, noise_snr, random_key):
    radii_for_mask = noise_grid[None, :] ** 2 + noise_grid[:, None] ** 2
    mask = radii_for_mask < noise_radius_mask**2

    signal_power = jnp.sqrt(jnp.sum((image * mask) ** 2) / jnp.sum(mask))

    noise_power = signal_power / jnp.sqrt(noise_snr)
    image = image + jax.random.normal(random_key, shape=image.shape) * noise_power

    return image, noise_power


batch_simulator_ = jax.vmap(
    simulator_, in_axes=(None, None, None, None, None, 0)
)

batch_add_noise_ = jax.vmap(add_noise_, in_axes=(0, None, None, 0, 0))


def simulate_stack(
    models: ArrayLike,
    struct_info: ArrayLike,
    images_per_model: list,
    config: dict,
    batch_size: Union[int, None] = None,
    dtype: type = float,
    seed: int = 0,
) -> ImageStack:
    """
    Simulate a stack of images.

    Parameters
    ----------
    models : ArrayLike
        Array of shape (n_models, n_atoms, 3) with the coordinates of the atoms.
    struct_info : ArrayLike
        Structural information of the models.
    images_per_model : list
        List of length n_models with the number of images to simulate for each model.
    config : dict
        Dictionary with the following keys:
            - box_size : int
                Size of the box in pixels.
            - pixel_size : float
                Size of a pixel in Angstroms.
            - res : float
                Standard deviation of the Gaussian that represents the atomic scattering.
            - noise_radius_mask : int
                Radius of the mask that defines the signal for the noise calculation.
            - ctf_defocus : float or list of [min, max]
                Defocus value or range of values.
            - ctf_amp : float or list of [min, max]
                Amplitude contrast value or range of values.
            - ctf_bfactor : float or list of [min, max]
                B-factor value or range of values.
            - noise_snr : float or list of [min, max]
                Signal-to-noise ratio value or range of values.
    batch_size : Union[int, None], optional
        Batch size for the image generation, by default None (Unused right now)
    dtype : type, optional
        Data type of the parameters and the images, by default jax.numpy.float32
    seed : int, optional
        Seed for the random number generator, by default 0

    Returns
    -------
    image_stack : ImageStack
        ImageStack object with the simulated images and their parameters.
    """

    n_images = np.sum(images_per_model)

    image_stack = ImageStack()

    image_stack.init_for_stacking(
        n_images=n_images,
        box_size=config["box_size"],
        pixel_size=config["pixel_size"],
        res=config["res"],
        noise_radius_mask=config["noise_radius_mask"],
        dtype=jnp.float32,
    )

    key = jax.random.PRNGKey(seed)

    for i in range(models.shape[0]):
        key, *subkeys = jax.random.split(key, num=images_per_model[i] + 1)
        subkeys = jnp.array(subkeys)

        variable_params = generate_params_(
            n_images=images_per_model[i], config=config, dtype=dtype
        )

        batch_images = batch_simulator_(
            models[i],
            struct_info,
            image_stack.grid,
            image_stack.grid_f,
            config["res"],
            variable_params,
        )

        batch_images, noise_variances = batch_add_noise_(
            batch_images,
            image_stack.noise_grid,
            config["noise_radius_mask"],
            variable_params[:, 9],
            subkeys,
        )

        variable_params[:, 10] = noise_variances
        image_stack.stack_batch(batch_images, variable_params)

    return image_stack


# batch_over_models_simulator = jax.vmap(
#     full_simulator_, in_axes=(0, None, None, None, None, 0, 0)
# )


# def simulate_stack_traj(
#     models,
#     config: dict,
#     dtype: type = float,
#     seed: int = 0,
# ):
#     image_stack = ImageStack()

#     image_stack.init_for_stacking(
#         n_images=models.shape[0],
#         box_size=config["box_size"],
#         pixel_size=config["pixel_size"],
#         res=config["res"],
#         noise_radius_mask=config["noise_radius_mask"],
#         dtype=jnp.float32,
#     )

#     variable_params = generate_params_(
#         n_images=models.shape[0], config=config, dtype=dtype
#     )

#     key = jax.random.PRNGKey(seed)

#     key, *subkeys = jax.random.split(key, num=models.shape[0] + 1)
#     subkeys = jnp.array(subkeys)

#     batch_images, noise_variances = batch_over_models_simulator(
#         models,
#         config["box_size"],
#         config["pixel_size"],
#         config["res"],
#         config["noise_radius_mask"],
#         variable_params,
#         subkeys,
#     )

#     variable_params[:, 10] = noise_variances
#     variable_params = jnp.array(variable_params)

#     image_stack.stack_batch(batch_images, variable_params)

#     return image_stack
